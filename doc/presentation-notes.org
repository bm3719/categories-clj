* Category Theoretic Clojure

State of Clojure.  Low academia/science use.

Open discussion.  Not an expert.
* Monads

Sometimes misattributed to Simon Peyton Jones.

Actually not true.

Also intentionally confusing.
* Actually...

Hopefully more clear

Now let's write some code.
* Category Theory

An attempt to formalize and abstract out things at the highest level.

A field of mathematics, often used to study other fields of mathematics.

Sometimes it's criticized for this, labeled "abstract nonsense".

Also used extensively in physics and, of course, computer science.

* Why category theory?

Programmers create abstractions.

Idris is a dependently typed pure FPL with theorem prover features.  However,
it's a general purpose language.

Also possible in dynamic functional languages, as we'll see.

CT is just another mathematical abstraction, like:
- formal logic
- lambda calculus
- type theory (in the form of the more formal type systems)
- sets

* Set theory analogy

properties: unordered, no repeats.
mutate set: add, remove

The empty set is an object in Set

Other examples: Natural numbers, rationals

* The Category

Let's at least cover a formal definition of a category.

Category:
- Collection of objects and morphisms.
- Morphisms have domains and codomains.
- Every object has an identity morphism.
- Morphisms can be composed.
  f: A -> B
  g: B -> C
  gf: A -> C
- Morphisms are associative.

Normally, I'd build up from here, cover functors, applicatives, monoids, then
monads.  Let's skip ahead to actually using some concepts though.

* Haskell

Here's some of the CT coverage in Haskell.  Only Apply, Comonad, and
Semigroup have yet to be implemented

Typeclasses are kinda like Java interfaces, but not exactly.  Differences:
- Interface methods are associated with an object instance.
- No concept of a Java class attached to implementation of an interface.
- Typeclasses allow for default implementations.

:t "hi"

The == function can illustrate this.

What's the type of ==?

=> is a class constraint.

We see it takes a parameter of typeclass Eq.

Run: :info Eq

* Functors

Now that we know what a typeclass is, we can cover functors.

:t map

map (+ 1) [1,2,3,4]

:t fmap

fmap (+ 1) [1,2,3,4]

Why's this work?

:info []

[] is an instance of Functor.

In CT, functors are homomorphisms (a structure-preserving map) between
categories.


* Monads

What's going on here?

return and one of the bind functions have type signatures and require
implementations.

The last two functions have default implementations.

Note that this differs a little from the formal CT definition that we didn't
cover.  For example, a monad is defined as a triple of an endofunctor and two
natural transformations.  One of those, return, should be called eta.

* The Maybe monad

The Maybe monad is probably one of the simpler monads.

:t Just 1
:t Maybe

f :: Int -> Maybe Int
f 0 = Nothing
f x = Just x

Now that we have a Maybe monad, we can fmap over it.

fmap (+ 1) (Just 2)

* cats

Great documentation, which is also very educational.

None of the CT libs have a ton of activity though.

composing/decomposing

(defn query-gender-maybe []
  (cats/fmap #(str "demi-" %)
             (rand-nth [(maybe/just (rand-nth my-genders))
                        (maybe/nothing)])))

* Other category theory libraries

algo.monads was the first, written by Rich.

* Some random observations

Category theory concepts can be a part of the business logic of your program.
E.g. data analytic framework.

Categories in statically typed languages retain the notion that CT is for
composition.  In cats, we can decompose at will.  Though perhaps we can
exercise discipline.

Dependently typed theorem provers are mostly heavily categorical.

Has Rich, Stu, or other core language people said anything about it?

* resources
